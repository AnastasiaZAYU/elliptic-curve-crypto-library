# Комп'ютерний практикум #2: Реалізація класичних криптосистем на базі еліптичних кривих
## Мета лабораторної роботи
Отримання практичних навичок програмної реалізації класичних криптосистем на базі еліптичних кривих, закріплення теоретичного матеріалу, отриманого на лекційних заняттях.

## Завдання
1. **Реалізувати схему ключового обміну Діффі-Геллмана на еліптичних кривих (ECDH)** та перевірити коретність узгодження спільного секрету.
2. **Реалізувати алгоритм направленого шифрування на базі ефемерного ключового обміну Діффі-Геллмана на еліптичних кривих** та перевірити коректність, зашифрувавши довільне повідомлення.
3. **Реалізувати схему цифрового підпису згідно алгоритму ECDSA** та перевірити коректність: підписати довільний байтовий рядок, а згодом перевірити підпис.

## Деталі реалізації

Проєкт реалізовано мовою програмування **Python** і складається з трьох основних файлів: `EllipticCurve.py`, `CurvePoint.py` та `EllipticCurves_lab2.ipynb`.

### Загальні компоненти

* `EllipticCurve.py` та `CurvePoint.py`: ці файли містять класи для роботи з еліптичними кривими та їх точками, що були розроблені в рамках Комп'ютерного практикуму №1. Вони надають базові операції, такі як додавання та подвоєння точок, скалярне множення, а також перетворення між афінними та проективними координатами.

### Ключовий обмін Діффі-Геллмана на еліптичних кривих (ECDH)

* **Опис**: реалізовано функцію `generate_keys(P)` для генерації пари приватний/публічний ключ (`d`, `Q`), де `Q = dP`. Продемонстровано узгодження спільного секрету між двома сторонами (Алісою та Бобом) шляхом обчислення `S = d_A * Q_B = d_B * Q_A`.
* **Файл**: `EllipticCurves_lab2.ipynb`

### Направлене шифрування на базі ефемерного ECDH

* **Опис**: реалізовано алгоритм направленого шифрування, який дозволяє зашифрувати повідомлення для конкретного одержувача, використовуючи його публічний ключ.
    * **Функція `encrypt(M, P, Qb)`**: шифрує повідомлення `M`, використовуючи публічний ключ `Qb` одержувача. Вона генерує ефемерну пару ключів, обчислює спільний секрет, на його основі обгортає сесійний ключ AES, а потім шифрує повідомлення цим сесійним ключем.
    * **Функція `decrypt(Env, db)`**: розшифровує повідомлення, використовуючи приватний ключ `db` одержувача. Вона розгортає сесійний ключ та розшифровує повідомлення.
* **Файл**: `EllipticCurves_lab2.ipynb`

### Цифровий підпис за алгоритмом ECDSA

* **Опис**: реалізовано стандартний алгоритм цифрового підпису на еліптичних кривих (ECDSA).
    * **Функція `H(M, mod)`**: геш-функція SHA-3 256, що використовується для обчислення гешу повідомлення.
    * **Функція `sign(M, P, da)`**: генерує цифровий підпис `(r, s)` для повідомлення `M` за допомогою приватного ключа `da` підписувача.
    * **Функція `verify(M, r, s, Qa)`**: перевіряє коректність підпису `(r, s)` для повідомлення `M`, використовуючи публічний ключ `Qa` підписувача.
* **Файл**: `EllipticCurves_lab2.ipynb`
